using System.Collections.Generic;
using GameEngine.GameObjects;
using Microsoft.Xna.Framework;

namespace GameEngine.DataStructures
{
    public class QuadTree
    {       
        public QuadTreeNode Root { get; private set; }
        public int EntityLimit { get; private set; }
        public int pxTileWidth { get; private set; }
        public int pxTileHeight { get; private set; }

        internal int currentNodeIndex = 1;

        public QuadTree(int txWidth, int txHeight, int pxTileWidth, int pxTileHeight, int EntityLimit=1)
        {
            Root = GetQuadTreeNode(0, 0, pxTileWidth * txWidth, pxTileHeight * txHeight, null);
            this.EntityLimit = EntityLimit;
            this.pxTileWidth = pxTileWidth;
            this.pxTileHeight = pxTileHeight;
        }

        /// <summary>
        /// Updates the appropriate Nodes in the QuadTree associated with the Entity due to some 
        /// change that occured during an update loop. The detected change is entirely based on
        /// the internal prevPxBoundingBox variable associated with the Entity.
        /// </summary>
        /// <param name="Entity">Entity to update in the QuadTree.</param>
        public void Update(Entity Entity)
        {
            List<QuadTreeNode> Buffer = new List<QuadTreeNode>();
            Rectangle dummyBox = Entity.CurrentPxBoundingBox;
            
            Entity.CurrentPxBoundingBox = Entity.prevPxBoundingBox;

            Remove(Entity);
            Entity.CurrentPxBoundingBox = dummyBox;

            Add(Entity);
        }

        /// <summary>
        /// Completely Removes the specified Entity from the association with this QuadTree. The
        /// method will automatically clean up any un-needed nodes that may have been created from
        /// the Removal process.
        /// </summary>
        /// <param name="Entity"></param>
        public void Remove(Entity Entity)
        {
            List<QuadTreeNode> associations = new List<QuadTreeNode>();
            Root.GetAssociatedNodes(Entity, ref associations);

            foreach (QuadTreeNode node in associations)
            {
                node.Entities.Remove(Entity);
                node.Validate();
            }
        }

        /// <summary>
        /// Adds the specified Entity to the QuadTree, recursivel building any required child QuadTreeNodes
        /// along the way if needed.
        /// </summary>
        /// <param name="Entity">Entity object to add to the QuadTree</param>
        public void Add(Entity Entity)
        {
            Root.Add(Entity);
        }

        /// <summary>
        /// Rebuilds the QuadTree based on the input entities passed in the functions
        /// parameter. The function tries to be as cheap as possible by re-using previously
        /// insantiated objects in previous calls.
        /// </summary>
        /// <param name="Entities">Collection of Entities to build the QuadTree out of.</param>
        public void Rebuild(ICollection<Entity> Entities)
        {
            Root.Clear();

            foreach (Entity entity in Entities)
                Add(entity);
        }

        /// <summary>
        /// Factory method for Generating QuadTreeNodes associated with this QuadTree. Automatically assigns
        /// and increments the currentNodeIndex value to allow unique identification of Nodes in the tree 
        /// when required.
        /// </summary>
        /// <param name="px">x location of the Node in pixels.</param>
        /// <param name="py">y location of the Node in pixels.</param>
        /// <param name="pxWidth">Width of the Node in pixels.</param>
        /// <param name="pxHeight">Height of the Node in pixels.</param>
        /// <param name="Parent">Parent Node of this Node in the QuadTree.</param>
        /// <returns>The QuadTreeNode generated by this factory method.</returns>
        public QuadTreeNode GetQuadTreeNode(int px, int py, int pxWidth, int pxHeight, QuadTreeNode Parent)
        {
            QuadTreeNode nodeResult = new QuadTreeNode();
            nodeResult.Clear();
            nodeResult.NodeID = currentNodeIndex;
            nodeResult.pxBounds = new Rectangle(px, py, pxWidth, pxHeight);
            nodeResult.QuadTree = this;
            nodeResult.Parent = Parent;

            currentNodeIndex++;

            return nodeResult;
        }

        /// <summary>
        /// Returns all intersecting Entities found in that region based on the
        /// CurrentPxBoundingBox property exposed by the Entity (which would have
        /// been last updated by the TeeEngine Update loop).
        /// </summary>
        /// <param name="pxRegion">Rectangle region to check in Pixels.</param>
        /// <returns>List of Entity objects intersecting the specified region.</returns>
        public List<Entity> GetIntersectingEntites(Rectangle pxRegion)
        {
            List<Entity> result = new List<Entity>();
            Root.GetIntersectingEntities(pxRegion, ref result);

            return result;
        }

        public override string ToString()
        {
            return string.Format("QuadTree:pxWidth={1}, pxHeight={2}",
                Root.pxBounds.Width,
                Root.pxBounds.Height);
        }
    }
}
